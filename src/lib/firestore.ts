import {
  collection,
  addDoc,
  getDocs,
  getDoc,
  doc,
  updateDoc,
  deleteDoc,
  query,
  where,
  Timestamp, // Import Timestamp for date fields
  WhereFilterOp, // Explicitly import WhereFilterOp
  setDoc, // Import setDoc
} from 'firebase/firestore';
import { db } from '@/lib/firebase'; // Adjusted path

// Import the new Firestore data model interfaces
import type {
  UserProfile,
  AiWriterExecution,
  VideoDetails,
  ScriptComponent,
  AnalysisReport,
} from './types/firestore'; // Path relative to firestore.ts

// Define collection names for type safety and consistency
export const COLLECTIONS = {
  USERS: 'users',
  AI_WRITER_EXECUTIONS: 'aiWriterExecutions',
  VIDEO_DETAILS_CACHE: 'videoDetailsCache',
  SCRIPT_COMPONENT_LIBRARY: 'scriptComponentLibrary',
  ANALYSIS_REPORTS: 'analysisReports',
} as const;

// Type for collection names
export type CollectionName = typeof COLLECTIONS[keyof typeof COLLECTIONS];

// Interface mapping collection names to their data types
interface FirestoreCollectionMap {
  [COLLECTIONS.USERS]: UserProfile;
  [COLLECTIONS.AI_WRITER_EXECUTIONS]: AiWriterExecution;
  [COLLECTIONS.VIDEO_DETAILS_CACHE]: VideoDetails;
  [COLLECTIONS.SCRIPT_COMPONENT_LIBRARY]: ScriptComponent;
  [COLLECTIONS.ANALYSIS_REPORTS]: AnalysisReport;
  // Add other collections here as they are defined
}

// BaseDocument is still useful for common properties, ensure it's compatible
// with all types in FirestoreCollectionMap or adjust as needed.
// All our types have `id?: string`, `createdAt: Timestamp`, `updatedAt?: Timestamp`
// so the BaseDocument definition is compatible.
interface BaseDocument {
  id?: string; // Firestore document ID, will be populated upon retrieval
  createdAt?: Timestamp; // Handled by createDocument
  updatedAt?: Timestamp; // Handled by updateDocument
}

// Create a new document
export const createDocument = async <CName extends CollectionName>(
  collectionName: CName,
  // Data to create the document, 'id' is auto-generated by Firestore,
  // 'createdAt' is set by this function. 'updatedAt' is not relevant here.
  // We also need to ensure that fields that are optional on read (like 'id')
  // are not expected in the input data type for creation if they are truly auto-generated or optional at creation.
  // Omit 'id' as it's the doc ID. Omit 'createdAt' & 'updatedAt' as they are set by backend/triggers or these functions.
  data: Omit<FirestoreCollectionMap[CName], 'id' | 'createdAt' | 'updatedAt'>
): Promise<string> => { // Returns the new document's ID
  try {
    const docData = {
      ...data,
      createdAt: Timestamp.now(), // Set creation timestamp
    };
    // Type assertion for 'data' to match what addDoc expects, which is DocumentData
    const docRef = await addDoc(collection(db, collectionName), docData as any); // Using 'as any' for now due to complex type inference with Firestore
    return docRef.id;
  } catch (error) {
    console.error(`Error adding document to ${collectionName}:`, error);
    throw error;
  }
};

// Get all documents from a collection
export const getDocuments = async <CName extends CollectionName>(
  collectionName: CName
): Promise<FirestoreCollectionMap[CName][]> => {
  try {
    const querySnapshot = await getDocs(collection(db, collectionName));
    return querySnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
    } as FirestoreCollectionMap[CName])); // Cast to the specific collection type
  } catch (error) {
    console.error(`Error getting documents from ${collectionName}:`, error);
    throw error;
  }
};

// Get documents with a where clause
export const getDocumentsWhere = async <CName extends CollectionName>(
  collectionName: CName,
  field: keyof FirestoreCollectionMap[CName] & string, // Ensure field is a key of the document type
  operator: WhereFilterOp,
  value: any // Value type can be broad for a generic function
): Promise<FirestoreCollectionMap[CName][]> => {
  try {
    const q = query(collection(db, collectionName), where(field, operator, value));
    const querySnapshot = await getDocs(q);
    return querySnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
    } as FirestoreCollectionMap[CName])); // Cast to the specific collection type
  } catch (error) {
    console.error(`Error querying documents from ${collectionName}:`, error);
    throw error;
  }
};

// Get a single document by ID
export const getDocument = async <CName extends CollectionName>(
  collectionName: CName,
  id: string
): Promise<FirestoreCollectionMap[CName] | null> => {
  try {
    const docRef = doc(db, collectionName, id);
    const docSnap = await getDoc(docRef);

    if (docSnap.exists()) {
      return { id: docSnap.id, ...docSnap.data() } as FirestoreCollectionMap[CName]; // Cast
    } else {
      console.log(`No such document in ${collectionName} with id ${id}`);
      return null;
    }
  } catch (error) {
    console.error(`Error getting document ${id} from ${collectionName}:`, error);
    throw error;
  }
};

// Update a document
export const updateDocument = async <CName extends CollectionName>(
  collectionName: CName,
  id: string,
  // Data to update. Partial allows any subset of fields.
  // Omit 'id' and 'createdAt' as they shouldn't be updated directly through this.
  // 'updatedAt' is set by this function.
  data: Partial<Omit<FirestoreCollectionMap[CName], 'id' | 'createdAt' | 'updatedAt'>>
): Promise<boolean> => {
  try {
    const docRef = doc(db, collectionName, id);
    const updateData = {
      ...data,
      updatedAt: Timestamp.now(), // Set update timestamp
    };
    await updateDoc(docRef, updateData as any); // Using 'as any' for now
    return true;
  } catch (error) {
    console.error(`Error updating document ${id} in ${collectionName}:`, error);
    throw error;
  }
};

// Delete a document
export const deleteDocument = async (
  collectionName: string,
  id: string
): Promise<boolean> => {
  try {
    await deleteDoc(doc(db, collectionName, id));
    return true;
  } catch (error) {
    console.error("Error deleting document:", error);
    throw error;
  }
};

// Set a document with a specific ID (useful for user profiles where ID is Auth UID)
export const setDocument = async <CName extends CollectionName>(
  collectionName: CName,
  id: string, // The ID for the document
  // Data to set. Unlike createDocument, this can be a full document update/creation.
  // We'll ensure createdAt is set on initial creation and updatedAt on modification.
  // For simplicity here, assume data might not have createdAt/updatedAt yet.
  data: Omit<FirestoreCollectionMap[CName], 'id' | 'createdAt' | 'updatedAt'>, // Data without managed fields
  merge = false // Whether to merge with an existing document or overwrite
): Promise<void> => {
  try {
    const docRef = doc(db, collectionName, id);
    // Check if document exists to conditionally set createdAt
    const docSnap = await getDoc(docRef);
    let documentData;
    if (!docSnap.exists()) {
      // Document is new, set createdAt
      documentData = {
        ...data,
        createdAt: Timestamp.now(),
        updatedAt: Timestamp.now(), // Also set updatedAt on creation
      };
    } else {
      // Document exists, only set updatedAt
      documentData = {
        ...data,
        updatedAt: Timestamp.now(),
      };
    }
    // Type assertion for documentData
    await setDoc(docRef, documentData as any, { merge });
  } catch (error) {
    console.error(`Error setting document ${id} in ${collectionName}:`, error);
    throw error;
  }
}; 